# 워크플로우 실전

> **이 문서의 목표:** 실제 기능 개발이 어떻게 진행되는지 구체적인 시나리오로 이해하기

---

## 1. 표준 7단계 워크플로우

모든 기능 개발은 이 흐름을 따릅니다:

```
1단계: 당신이 요청
2단계: MA가 분석 → REQ 초안
3단계: 당신이 REQ 승인
4단계: MA가 WI 분할 → 에이전트에게 위임 → 작업 실행
5단계: 에이전트가 결과 보고
6단계: 필요시 반복 (4~5)
7단계: 최종 완료 보고
```

---

## 2. 실전 시나리오: "회원가입 API 만들기"

### 1단계: 요청

```
당신: "이메일/비밀번호 기반 회원가입 API를 만들어줘.
      중복 이메일 체크하고, 비밀번호는 BCrypt로 암호화해줘."
```

### 2단계: MA 분석 → REQ 초안

MA가 이렇게 응답할 수 있습니다:

```
REQ-20260212-ATS-001 초안을 작성했습니다.

[목표]
- 이메일/비밀번호 기반 회원가입 REST API 구현

[범위]
- 포함: Member 엔티티, 가입 API, 중복 체크, 비밀번호 암호화
- 제외: 이메일 인증, 소셜 로그인

[성공 기준]
- POST /api/members/signup 으로 가입 가능
- 중복 이메일 시 409 Conflict 반환
- 비밀번호 BCrypt 암호화 저장
- 가입 성공 시 201 Created + 사용자 정보 반환
- 단위 테스트 통과

[제약]
- Java 17 + Spring Boot 4.x
- MySQL 8.x
- Lombok 사용

이대로 진행할까요? 수정할 사항이 있으면 말씀해주세요.
```

### 3단계: 승인

```
당신: "좋아, 진행해. 근데 가입 성공 시 JWT 토큰도 같이 반환해줘."
```

→ MA가 REQ를 업데이트하고 진행합니다.

### 4단계: 작업 분할 및 실행

MA가 내부적으로 이렇게 분할합니다:

| WI | 에이전트 | 작업 | 순서 |
|----|---------|------|------|
| WI-001 | sa | Member 엔티티 설계 | 1 (먼저) |
| WI-002 | se | Entity, DTO, Repository 구현 | 2 |
| WI-003 | se | Service, Controller 구현 | 3 |
| WI-004 | pg | 비밀번호 암호화, JWT 설정 검토 | 2 (병렬) |
| WI-005 | re | 단위 테스트 작성 | 4 (마지막) |

### 5단계: 결과 보고

```
MA: "회원가입 API 구현이 완료되었습니다.

[생성된 파일]
- src/main/java/.../entity/Member.java
- src/main/java/.../dto/SignupRequest.java
- src/main/java/.../dto/SignupResponse.java
- src/main/java/.../repository/MemberRepository.java
- src/main/java/.../service/MemberService.java
- src/main/java/.../controller/MemberController.java
- src/test/java/.../service/MemberServiceTest.java

[테스트 결과]
- 5개 테스트 모두 통과

[API 스펙]
- POST /api/members/signup
  - Request: { email, password, nickname }
  - Response 201: { id, email, nickname, accessToken }
  - Response 409: { message: '이미 가입된 이메일입니다' }

확인해주세요."
```

### 6~7단계: 확인 및 완료

```
당신: "코드 확인했어. 잘 된 것 같아. 완료!"
```

또는:

```
당신: "좋은데, nickname에 길이 제한 추가해줘. 2~20자로."
→ 추가 수정 반복 후 완료
```

---

## 3. 시나리오 유형별 흐름 차이

### 간단한 작업 (LOW)

```
당신: "Music 엔티티에 duration 필드 추가해줘. Integer, 초 단위."

→ MA가 REQ 없이 바로 진행할 수도 있음 (범위가 명확하므로)
→ 또는 간단한 확인 후 바로 실행
```

**포인트:** 단순한 필드 추가 같은 건 REQ 작성 없이 빠르게 진행됩니다.

### 중간 규모 작업 (MEDIUM)

```
당신: "음악 검색 API를 만들어줘. 제목, 장르로 검색, 페이징 포함."

→ REQ 작성 → 승인 → 설계 → 구현 → 테스트 → 보고
→ ADR(아키텍처 결정 기록)도 남길 수 있음
```

### 대규모 작업 (HIGH)

```
당신: "결제 시스템을 도입하고 싶어."

→ REQ 작성 (매우 상세) → 승인
→ 여러 WI로 분할
→ 아키텍처 설계 → 설계 승인 (추가 승인 필요!)
→ 구현 → 보안 검토 → 테스트 → 보고
→ 최종 승인
```

**포인트:** HIGH 작업은 **중간에 추가 승인 포인트**가 있습니다 (설계 승인, 보안 검토 등).

---

## 4. 마일스톤 게이트 — 중간 점검

대규모 작업에서는 3개의 마일스톤 게이트가 있습니다:

| 마일스톤 | 시점 | 당신이 확인할 것 | 질문 |
|---------|------|----------------|------|
| **M1: 계획 확정** | WI 분할 후 | 작업 목록, 예상 범위 | "내 의도를 제대로 이해했나?" |
| **M2: 설계 확정** | 설계 완료 후 | 설계 문서, ADR | "이렇게 만들어도 되나?" |
| **M3: 구현 완료** | 구현 + 테스트 후 | 코드, 테스트 결과 | "결과에 만족하나?" |

### M1~M3 각각에서 당신이 할 일

```
MA: "M1 계획 확정 — 이렇게 분할했습니다. [작업 목록]"
당신: "좋아, 진행해" / "WI-003은 빼자" / "이것도 추가해줘"

MA: "M2 설계 확정 — 이런 구조로 설계했습니다. [설계 문서]"
당신: "오케이" / "여기 테이블 구조 바꾸자"

MA: "M3 구현 완료 — 결과입니다. [코드 + 테스트]"
당신: "확인, 완료!" / "이 부분 수정해줘"
```

---

## 5. 병렬 작업 (여러 기능 동시 개발)

### 가능한 경우

서로 의존성이 없는 작업은 병렬로 진행 가능:

```
당신: "회원가입 API와 음악 목록 API를 동시에 만들어줘"

→ WI 그룹 A: 회원가입 (독립)
→ WI 그룹 B: 음악 목록 (독립)
→ 동시 진행 가능!
```

### 주의할 경우

의존성이 있으면 순서가 중요:

```
당신: "로그인 API를 만들고, 그 다음에 인증된 사용자만 음악 업로드하게 해줘"

→ 로그인 API (먼저) → 음악 업로드 (다음)
→ 순차 진행
```

---

## 6. 실전에서 자주 만나는 상황

### "빌드가 안 돼요"

```
당신: "빌드 에러 나는데 확인해줘" (또는 /build-check)
MA: 에러 분석 → 수정 → 재빌드 → 보고
```

### "테스트가 실패해요"

```
당신: "테스트 실패하는데 원인 찾아줘" (또는 /test)
MA: 실패 원인 분석 → 수정 → 재테스트 → 보고
```

### "코드 리뷰 해줘"

```
당신: "MemberService 코드 리뷰 해줘"
MA: cr 에이전트 호출 → 리뷰 결과 보고
```

### "설계를 먼저 보고 싶어"

```
당신: "구현하기 전에 설계부터 보여줘"
MA: sa 에이전트로 설계 → 당신에게 설계 문서 보고 → 승인 후 구현
```

---

## 7. 작업 취소/변경

### 진행 중 취소

```
당신: "이 작업 멈춰. 방향을 바꿔야 할 것 같아."
MA: 현재 진행 상황 정리 → 중단 → 새 방향 대기
```

### 범위 축소

```
당신: "전부 다 하지 말고, 기본 CRUD만 먼저 해줘."
MA: REQ 범위 조정 → 해당 범위만 진행
```

### 범위 확대

```
당신: "여기에 이메일 인증도 추가하고 싶어."
MA: 추가 범위 영향 분석 → 변경된 REQ → 승인 후 진행
```

---

## 8. 이 워크플로우를 안 따르면?

- 에이전트가 "이건 REQ 승인이 필요합니다"라고 먼저 안내할 수 있음
- 간단한 작업은 생략 가능 (MA가 판단)
- **핵심은**: 큰 작업일수록 이 프로세스가 **당신을 보호**함
  - 잘못된 방향으로 많은 코드를 쓴 후 엎는 것보다
  - REQ에서 방향을 확인하는 것이 100배 효율적

---

**다음:** [실전 팁과 주의사항](05-실전-팁과-주의사항.md) — 시행착오를 줄이는 노하우